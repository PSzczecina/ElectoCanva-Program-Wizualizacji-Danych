<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
      integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
      crossorigin=""
    />
    <script
      src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
      integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
      crossorigin=""
    ></script>
    <title>Piękno, Radość, Szczęście</title>
    <link rel="stylesheet" href="style.css" />
  </head>
  <body>
    <nav>
      <a class="disabled">Strona Główna</a>
      <a href="mapa.html">Mapa</a>
      <a>Wykresy</a>
      <a>Do Pobrania</a>
    </nav>
    <section>
      <h1>ElectoCanva* - Program wizualizacji danych</h1>
      <p>Aplikacja ta stanowi główną część projektu licencjackiego.</p>
      <p>
        Celem projektu jest aplikacja do przystępnej prezentacja danych
        wyborczych w Polsce. Funkcjonalność obejmuje:
      </p>
      <ul>
        <li>
          Użycie kartogramów, wykresów słupkowych, liniowych, bąbelkowych,
        </li>
        <li>
          Wyświetlanie danych frekwencji, zwycięzców/zwycięskich bloków w
          poszczególnych regionach, wspólne wyświetlenie informaci o frekwencji
          z różnicą wyników,
        </li>
        <li>
          Grupowanie kandydatów w wyborach na bloki
          (prawica/centrum/lewica/inni),
        </li>
        <li>
          Porównywanie danych z dwóch różnych wyborów (np. Zmiana frekwencji
          między wyborami parlamentranymi 2019 a prezydenckimi 2020, zmiana
          poparcia między kandydatami "prawicy" z wyborów parlamentarnych 2019 a
          prezydenckich 2025, etc.)
        </li>
      </ul>
      <p>
        Dane przekonwertowano z xls/xlsx na pliki Json o ustandaryzowanym
        formacie za pomocą programu w Pythonie. Oryginalne dane wybrocze wzięto
        z
        <a
          target="_blank"
          href="https://danewyborcze.kbw.gov.pl/indexc4fa.html?title=Strona_g%C5%82%C3%B3wna"
          >oficjalnej strony Państwowej Komisji Wyborczej</a
        >. Gotowe dane Json granic administracyjnych wzięto z
        <a href="https://github.com/jusuff/PolandGeoJson" target="_blank">
          dostępnego publicznie repozytorium na GitHubie </a
        >.
      </p>
      <h6>*nazwa w.i.p.</h6>
    </section>
  </body>
  <!--script type="module">
    //jak na razie dla samych gmin. Trzeba dorobić dla powiatów/województw jeszcze
    import geoDataGminy from '/data/GeoJson/poland.municipalities.json' with {type: 'json'};
    import geoDataPowiaty from '/data/GeoJson/poland.counties.json' with {type: 'json'};
    import geoDataWojewodztwa from '/data/GeoJson/poland.voivodeships.json' with {type: 'json'};

    import testData from '/data/prezydenckie/2025_prezy_2tura.json' with {type: 'json'};
    //próba dla powiatów

    console.log(testData.rok, testData.rodzaj_wyborów, testData.tura)

    //znajdź największą i najmniejszą wartość w jsonie
    var maxinset = 0
    var mininset = 1
    Object.keys(testData).forEach((k)=>{
      var turnoutpercent = testData[k].liczba_wyborców_obecnych/testData[k].liczba_wyborców_uprawnionych
      if (turnoutpercent < mininset && !isNaN(turnoutpercent)) mininset = turnoutpercent
      if (turnoutpercent > maxinset && !isNaN(turnoutpercent)) maxinset = turnoutpercent
      if (maxinset ==1) console.log(k, maxinset)
    })
    console.log(mininset*100, maxinset*100)
    //

    var map = L.map('map').setView([52, 19], 13);

    L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
      minZoom: 6,
      maxZoom:10,
      attribution:
        '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>',
    }).addTo(map);

    map.setZoom(6)
    map.setMaxBounds(map.getBounds())
    map.setZoom(7)
    function style(feature){
      return {
      "color": '#666666',
      "fillColor":colorRegion(calculateDensity(feature.properties.terc)),
      "weight": .5,
      "opacity":1,
      "fillOpacity":.75
    }
    }


    var geojson;

    function highlightFeature(e){
      //console.log(e.target.feature.properties.terc)
      var layer = e.target;
      layer.setStyle({
        weight: 5,
        color: "#000000",
        dashArray: '',
        fillOpacity: 1
      });
      layer.bringToFront();
    }
    function resetHighlight(e){
      geojson.resetStyle(e.target);
    }
    function onEachFeature(feature, layer) {
      layer.on({
        mouseover: highlightFeature,
        mouseout: resetHighlight,
      })
    }
    geojson = L.geoJson(geoDataGminy, {
      style: style,
      onEachFeature: onEachFeature
    });

    geojson.addTo(map)

    map.on('zoomed', function(){
      var currentZoom = map.getZoom()

    });

    function redrawGeoJson(){
      geojson.setStyle(feature => ({
      "color": '#666666',
      "fillColor":colorRegion(calculateDensity(feature.properties.terc)),
      "weight": .5,
      "opacity":1,
      "fillOpacity":.75
      }));
    }


    function calculateDensity(TERYT, geoDataType = 'gminy'){
      //console.log(TERYT)
      if (geoDataType == 'gminy'){
        TERYT = TERYT.slice(0,-1)
        if (TERYT == "146501" && testData.rok !=2005) {   //warszawa ma dzielnice, plik geojson ma całe miasto - trzeba je zsumować
          var warszawaObecni=0
          var warszawaUprawnieni=0
          for (var i =1; i<=18; i++){
          //console.log(TERYT)
            warszawaObecni += testData[parseInt(TERYT)+i].liczba_wyborców_obecnych
            warszawaUprawnieni += testData[parseInt(TERYT)+i].liczba_wyborców_uprawnionych
          }
          return warszawaObecni / warszawaUprawnieni
        }
        if (TERYT == "180710" && testData.rok <2010 ) {TERYT ="180702"} //gm Jaśliska - wydzielona została w 2010 roku
        if (TERYT == "026501") {if (testData.rok <=2013 && testData.rok >= 2003) TERYT = "022109"} //gmina wałbrzych - miała inny   teryt między 2002-2013
        if (TERYT == "060315" && testData.rok == 2005) {TERYT = "060608"} //gm rejowiec - zmieniła powiat
        var result = testData[TERYT].liczba_wyborców_obecnych / testData[TERYT].liczba_wyborców_uprawnionych
        return result
        }
      if (geoDataType == "powiaty") { //do zoptymalizowania
        var obecni = 0, uprawnieni = 0
        Object.keys(testData).forEach((k)=>{
          //console.log(testData[k])
          if (k.slice(0,4) == TERYT){
            obecni+=testData[k].liczba_wyborców_obecnych
            uprawnieni+=testData[k].liczba_wyborców_uprawnionych
          }
        //console.log(obecni, uprawnieni)
        })
        return obecni / uprawnieni
      }
      if (geoDataType == "województwa") {
        var obecni = 0, uprawnieni = 0
        Object.keys(testData).forEach((k)=>{
          //console.log(testData[k])
          if (k.slice(0,2) == TERYT){
            obecni+=testData[k].liczba_wyborców_obecnych
            uprawnieni+=testData[k].liczba_wyborców_uprawnionych
          }
        //console.log(obecni, uprawnieni)
        })
        return obecni / uprawnieni
      }
    }


    //gradienty trzeba czytelne zrobić
    function colorRegion(value, isAbsoluteValues=false){
      var relativeStages = document.getElementById("intervalCount").value
      var rangeTable = []
      if (isAbsoluteValues==false){
        var min = parseInt(document.getElementById("precentageMinSlide").value)/100
        var max = parseInt(document.getElementById("precentageMaxSlide").value)/100
        var diff = max-min
        for (var i=0; i<relativeStages;i++){
          rangeTable[i] = min + diff/relativeStages*i
        }
        for (var i=0;i<relativeStages;i++){
          if (value > rangeTable[relativeStages-1-i]) return rgb(255-(relativeStages-i)*16, i*40, i*40)
        }
        return rgb(255, relativeStages*40, relativeStages*40)
      }
      return value > 0.75 ? '#aa0000' :
      value > 0.50 ? '#ff4444' :
      value > 0.25 ? '#ff8888' :
      '#FFCCCC';
    }

    function rgb(r,g,b){
      return "rgb("+r+","+g+","+b+")"
    }

    const minValueText = document.getElementById("precentageMinValue")
    const maxValueText = document.getElementById("precentageMaxValue")
    document.getElementById("intervalCount").addEventListener("input", ()=>{
      redrawGeoJson()
    })
    document.getElementById("precentageMinSlide").addEventListener("input", (e) =>{
      redrawGeoJson()
      minValueText.innerHTML = document.getElementById("precentageMinSlide").value
    });
    document.getElementById("precentageMaxSlide").addEventListener("input", (e) =>{
      redrawGeoJson()
      maxValueText.innerHTML = document.getElementById("precentageMaxSlide").value
    });
  </script-->
</html>
